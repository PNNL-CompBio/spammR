---
title: "spammR microbiome evaluation"
author: "Yannick Mahlich"
package: spammR
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
    BiocStyle::html_document:
        toc: true
        number_sections: true
        toc_depth: 3
        toc_float:
            collapsed: true
description: |
  A basic walkthrough of how to use the spammR package to perform a spatial omics analysis for microbiome data. 
  
vignette: |
  %\VignetteIndexEntry{spammR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---

## Dependencies

This R-notebook relies on the following dependencies

### R packages

- [spammR](https://github.com/PNNL-CompBio/spammR)
- ggplot2
- [sf](https://r-spatial.github.io/sf/index.html) relies on other non R-libraries (see [Installing](https://r-spatial.github.io/sf/index.html#installing) for more details on how to install sf including the dependencies)

### non-R Libraries

- [GEOS](https://libgeos.org/usage/install/)
- [PROJ](https://proj.org/en/stable/install.html)
- [GDAL](https://gdal.org/en/stable/download.html)

### Setting up the evironment

```{r loading-packages, warning=FALSE, message=FALSE}
library(sf) 
library(terra)
library(ggplot2)
library(spammR)
library(plyr)
library(httr2)
library(tidyr)
library(dplyr)
```

## The Goal

The data that we will be working with is a KO enrichment from the 1000 soils project. The 1000 soils project has the nice feature that each location has two sampling at different depths. We will use this circumstance in combination with the KO enrichment to generate a pathway enrichment for each sample location and depth and then visualize the differential between the two depths.


## Performing the pathway enrichment

### Retrieving Pathway information from KEGG:

First we need to define which pathways we want to look at. Individual pathways identifiers can be found by fuzzy searching using the KEGG REST API. Let's say we want to look for the TCA cycle but aren't sure what the pathway is referred to in KEGG. We can fuzzy search 'cycle' and retrieve all related pathways using the following logic.

```{r}
searchterm = "cycle"
url <- paste("https://rest.kegg.jp/find/pathway/", searchterm, sep = "")
url |> 
  request() |>
  req_perform() |>
  resp_body_string() |>
  cat()
```
Let's say we want to get some more information on Glycolysis / Gluconeogenesis. This can be done by getting the pathway directly from KEGG via the following command.
```{r}
pathway <- "map00020"
url <- paste("https://rest.kegg.jp/get/", pathway, sep = '')
reply <- request(url) |> req_perform()
pathway_info <- reply |> 
  resp_body_string() |>
  cat()

pathway_info
```

As a next step we will be defining a function that can download and return a dataframe that contains pathway to KO mappings for a given KEGG pathway.

```{r}
ret_pathway_to_ko_list <- function(url) {
  reply <- request(url) |> req_perform()
  pathway_ko_list <- reply |> 
    resp_body_string() |> 
    read.table(text = _, col.names = c('pathway', 'ko')) |> 
    separate(data = _, col = 'pathway', into = c(NA, 'pathway'), sep = ':') |> 
    separate(data = _, col = 'ko', into = c(NA, 'ko'), sep = ':')
  return(pathway_ko_list)
}
```

Next we will create a named list with the pathways we want to investigate, for example the citrate cycle as well as pyruvate metabolism.
```{r}
pathways = c('map00020' = 'Citrate cycle (TCA cycle)', 'map00620' = 'Pyruvate metabolism')
```

Next we will retrieve a list of KOs that are associated with the pathways. This step will be crucial for the "pathway enrichment" that we will conduct based on the KO enrichment per sample that is provided by the 1000 soils project. 
```{r}
cols <- c('pathway', 'ko')
pathways_ko_lists = as.data.frame(matrix(numeric(), nrow = 0, ncol = length(cols)))

for (name in names(pathways)) {
  pathways_ko_lists <- paste("https://rest.kegg.jp/link/ko/", name, sep = '') %>% 
    ret_pathway_to_ko_list() %>% 
    rbind(pathways_ko_lists, .)
  Sys.sleep(0.5) # This is just so that in case the REST calls get processed to quickly we wait to not exceed the 3 per second limit of KEGG
}
```

Note one can also extract all pathway to KO information with the query below and perform further filtering afterwards.
```{r eval = FALSE}
url = "https://rest.kegg.jp/link/pathway/ko"
request(url) |>
  req_perform() |>
  resp_body_string() |>
  cat()
```


### Importing the KO enrichment information for 1000 soil samples

In the case of this example we will be importing KEGG Orthology data from the 1000 soils project.
The data is location mapped (we will be importing this data later) and contains KO abundances for individual locations. Further more for most sampling locations two samples are available ("TOP" & "BTM") which are extracted from the top and the bottom of the extracted soil core.

```{r}

prep_ko_data <- function(x, pathways, pathway_ko_list, suffix){
  ret <- FALSE
  
  for (pathway in pathways) {
    p <- names(which(pathways == pathway))
    t <- x[, grepl(suffix, colnames(x))] %>% 
      rename_with(~ sub(paste(suffix,"$", sep = ''), "", .x), everything()) %>%
      subset(., subset = row.names(.) %in% pathway_ko_list[pathway_ko_list$pathway == p,]$ko) %>% 
      apply(., 2, sum) %>%
      as.data.frame() %>%
      t()
    row.names(t) <- p
    if (typeof(ret) == 'logical') {
      cols <- names(t)
      ret <- as.data.frame(matrix(numeric(), nrow = 0, ncol = length(cols)))
    }
    ret <- rbind(ret, t)
  }
  return(ret)
}

```

```{r}
data_ko <- read.csv(file = "../data/1000_soil_contig_aug2022_all.csv", row.names = 1)

data_pathway_top <- prep_ko_data(data_ko, pathways, pathways_ko_lists, '_TOP')
data_pathway_btm <- prep_ko_data(data_ko, pathways, pathways_ko_lists, '_BTM')

data_pathway <- data_pathway_btm - data_pathway_top
```
### Omics Metadata

The KO metadata table will contain a mapping from KO identifier - row names in the Omics Measurement table - to a more descriptive annotation.

For testing purposes this currently is only the row names & incremented integer values.

```{r}

data_pathway_meta <- as.data.frame(pathways) %>% cbind(pathway = rownames(.), .)
colnames(data_pathway_meta) <- c('pathway', 'annotation')

# data_tmp <- read.csv(file = "../data/1000_soil_contig_aug2022_all.csv")
# data_ko_meta <- data_tmp["KO"]
# data_ko_meta["annotation"] <- seq(1, by = 1, length.out=nrow(data_ko_meta))
# data_ko_meta["annotation"] <- lapply(data_ko_meta["annotation"], as.character)
# head(data_ko_meta)
```


## Importing the long/lat data from the 1000 soils project

Next we need to import the lat/long information of the locations where the 1000 soil project samples where extracted. The file was retrieved from the [1000 Soils Project Shiny App](https://shinyproxy.emsl.pnnl.gov/app/1000soils). The metadata was retrieved by using the Query>Information tab. On the left side (the "Information Menu") we select `SAMPLE_ID`, `latitude` & `longitude` and download the resulting mapping.

Not all `Sample_ID` entries have complete lat/long data. To generate a `sf` object (see below) which will be needed as input to create a `terra:SpatRaster` object the input table can only contain complete cases (i.e. no `NaN` values).

```{r}
soil_metagenomes_coords <- read.csv(file='../data/1000_soil_contig_coords.csv', sep=',') %>%
  .[complete.cases(.),]
soil_metagenomes_coords$Sample_ID <- gsub("_[TOPBTM]+$", "", soil_metagenomes_coords$Sample_ID)
soil_metagenomes_coords <- unique(soil_metagenomes_coords)
  
head(soil_metagenomes_coords)
```


## File import

Importing a shape file containing the US states. The shape file was
retrieved from the [US Census Bureau](https://www.census.gov/cgi-bin/geo/shapefiles/index.php) with the following parameters:

- Year = 2024
- Layer type = "States (and equivalent)"

```{r import-usshape, warning=FALSE, message=FALSE}
s <- read_sf("../data/tl_2024_us_state/tl_2024_us_state.shp", quiet = TRUE)
s
```

Sub-setting the shape map to only US continental

```{r subsetting-us-map, warning=FALSE, message=FALSE}
us_continental = c(
  'WV', 'FL', 'IL', 'MN', 'MD', 'RI', 'ID', 'NH', 'NC', 'VT',
  'CT', 'DE', 'NM', 'CA', 'NJ', 'WI', 'OR', 'NE', 'PA', 'WA',
  'LA', 'GA', 'AL', 'UT', 'OH', 'TX', 'CO', 'SC', 'OK', 'TN', 
  'WY', 'ND', 'KY', 'ME', 'NY', 'NV', 'MI', 'AR', 'MS', 'MO',
  'MT', 'KS', 'IN', 'SD', 'MA', 'VA', 'DC', 'IA', 'AZ'
  )

s_us_cont = s[s$STUSPS %in% us_continental,]
s_us_cont
```
creating a "rasterization template" with `terra`. This will be needed to create an "actual" `terra::SpatRaster` object which we will use to generate a rasterized image while retaining the location information and possibility to project the map into a different map projection.

```{r raster-template, warning=FALSE, message=FALSE}
template <- rast(
  s_us_cont,
  res=0.01
  )
```
Creating the rasterized "landmass" of the continental US
```{r}

# us_raster <- rasterize(s_us_cont, template, background=0)
us_raster <- rasterize(s_us_cont, template)
```


## creating a SF object from the coordinate data

Next we generate a SF object from the coordinate data. This SF object can then be rasterized (see below).

```{r}
coords <- st_as_sf(soil_metagenomes_coords, coords=c('longitude', 'latitude'), remove=TRUE)
st_crs(coords) <- st_crs(s_us_cont)
coords
```

## transform the coordinates of the metagenome into a SpatRast object

The rasterization makes use of the same rasterization template that was used to rasterize the map of the continetal USA.

```{r}
coords_rast <- rasterize(coords, template)
coords_rast
```

## get the "Pixel" x/y (NOT lat/long x/y) of metagenome samples

Finally to retrieve the "pixel" coordinates instead of the x/y (lat/long) coordinates that are recorded in the `terra::SpatRaster` objects the following procedure is employed:

- use `extract()` to get the cells which the coordinates are projected into in the raster image
- use `lapply()` get the raster coordinates ('pixel' x/y) for each row with `terra::rowColFromCell()`
- use `cbind()` to combine the cells, 'pixel' x/y and original sample coordinate `data.frame`
- use `plyr::rename()` to clean up `data.frame`

This process does come with slight differences in lat/long. Most likely due to the rasterization process?

```{r}
cells <- extract(coords_rast, coords, xy=TRUE, cells=TRUE)
cells
```

```{r}
cells_tmp <- extract(coords_rast, coords, xy=TRUE, cells=TRUE)
xy_rast <- lapply(cells['cell'], function(x) rowColFromCell(coords_rast, x))
cells <- cells_tmp %>% 
  cbind(., soil_metagenomes_coords, xy_rast) %>%
  rename(., replace = c("cell.1" = "y_pixels", "cell.2" = "x_pixels")) %>%
  subset(., select = -c(x, y, ID, last))
cells$y_pixels <- nrow(coords_rast) - cells$y_pixels
```

Those need to be finally written out / transferred into the `spammR` package for further use.


## Exporting the rasterized map

The rasterized map can be exported with the command below.
```{r write-raster-map, eval=FALSE}
writeRaster(us_raster, '../data/us_map.png', NAflag=0, overwrite=TRUE)
```


## Examplary plotting 


```{r}
coords_test <- st_as_sf(soil_metagenomes_coords, coords=c('longitude', 'latitude'), remove=TRUE)
st_crs(coords_test) <- st_crs(s_us_cont)
plot(us_raster, col='grey')
plot(coords_test, col='red', add=TRUE)
```
## Generating the `SpatialExperiment` object

To generate the `SpatialExperiment` object that is needed by spammR we first need to compile the data that goes into that. The data is comprised of:

- Omics Measurements
- Omics Metadata
- Sample Metadata
- Image files (generated by the above code)


### Sample Metadata

Here we build the sample metadata table given the perviously generated coordinate raster during the rasterization of the map.

```{r}
data_meta <- cells
rownames(data_meta) <- data_meta$Sample_ID
# data_meta[,1] <- NULL
data_meta[,'cell'] <- NULL
data_meta[,'longitude.1'] <- NULL
data_meta[,'latitude.1'] <- NULL
data_meta[,'Image'] <- 0
data_meta[,'x_max'] <- ncol(coords_rast)
data_meta[,'y_max'] <- nrow(coords_rast)
data_meta[,'x_origin'] <- 0
data_meta[,'y_origin'] <- 0
data_meta[, 'spot_height'] <- 500
data_meta[, 'spot_width'] <- 500
head(data_meta)
```
### Actual generation of the `SpatialExperiment` object

```{r}
# microbiome.spe <- convert_to_spe(
#   d_test_ko,  ##pooled data table
#   d_test,  ##pooled metadata
#   d_test_ko_meta,  ##protein identifiers
#   feature_meta_colname='KO', #column name
#   spatialCoords_colnames=c('x_pixels','y_pixels'),
#   image_files = c("../data/us_map.png"),
#   image_samples_common_identifier='test',
#   samples_common_identifier='test',
#   image_ids = c('0'),
#   assay_name = 'KO'
#   )

# microbiome.spe <- convert_to_spe(
#   data_ko,  ##pooled data table
#   data_meta,  ##pooled metadata
#   data_ko_meta,  ##protein identifiers
#   feature_meta_colname='KO', #column name
#   spatialCoords_colnames=c('x_pixels','y_pixels'),
#   image_files = c("../data/us_map.png"),
#   image_samples_common_identifier='test',
#   samples_common_identifier='test',
#   image_ids = c('0'),
#   assay_name = 'KO'
#   )

microbiome.spe <- convert_to_spe(
  data_pathway,  ##pooled data table
  data_meta,  ##pooled metadata
  data_pathway_meta,  ##protein identifiers
  feature_meta_colname='pathway', #column name
  spatialCoords_colnames=c('x_pixels','y_pixels'),
  image_files = c("../data/us_map.png"),
  image_samples_common_identifier='test',
  samples_common_identifier='test',
  image_ids = c('0'),
  assay_name = 'pathway'
  )
```



```{r}
    spatial_heatmap(
      microbiome.spe,
      assay_name='pathway',
      feature='Citrate cycle (TCA cycle)',
      feature_type='annotation',
      sample_id='test',
      image_id='0',
      spatial_coord_names=c('x_pixels','y_pixels'),
      metric_display = "Pathway abundance",
      spot_size=unlist(colData(microbiome.spe)[1,c('spot_width','spot_height')]),
      image_boundaries=unlist(colData(microbiome.spe)[1,c('x_origin','y_origin','x_max','y_max')]),
      label_column='Sample_ID',
      interactive=FALSE,
      sample_label_color = 'grey',
      sample_label_size = 3,
      )
```

